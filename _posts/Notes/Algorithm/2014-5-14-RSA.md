---
layout: post
title: 初识RSA算法
date: 2014-05-14 23:37:00
categories: 笔记
tags: [RSA,Algorithm]
---

在我刚刚接触到公匙,私匙的概念的时候,总有一个词会夹带其中,那就是`RSA算法`,而百度百科和维基百科关于RSA的介绍,真心感觉不是写给正常人看的......

于是打算从阮大神写的[RSA算法原理(一)](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)和[RSA算法原理(二)](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)入手开始学习,看了一遍,感觉也不是很难理解,特此做下笔记.

有一种加密模式叫"非对称加密式算法",这种算法的好处是避免了直接传递密匙,大大提高了安全性,而RSA算法就是其中一种.

<img src="/public/upload/images/bg2013070301.png" alt="RSA" title="RSA">

加密模式如下:

>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。

>（2）甲方获取乙方的公钥，然后用它对信息加密。

>（3）乙方得到加密后的信息，用私钥解密。


当密匙越大的时候,破解难度越大,因为在破解的时候需要进行因式分解,而目前被破解的最长RSA密钥是768二进制位,即是232个十进制位,由此可见RSA算法是当今最安全的一种加密算法.

首先,先回顾一下以前(小学)学过的质数.

质数:一个大于1的自然数，如果除了1和它自身外，不能被其他自然数整除的数. <br>
其次再来理解作者在文章提到的互质关系.引用一下原文对于互质关系的定义:

>如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）

以及所下的结论:

>1. 任意两个质数构成互质关系，比如13和61。

>2. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。

>3. 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。

>4. 1和任意一个自然数是都是互质关系，比如1和99。

>5. p是大于1的整数，则p和p-1构成互质关系，比如57和56。

>6. p是大于1的奇数，则p和p-2构成互质关系，比如17和15。

满足于以上条件其中一条的两个数,就能构成互质关系,1,2,4条比较好理解,其他的得稍微分析一下.

第3条:较大的数是质数,那就代表了除了1以外的所有比它小的数都不是它的公因子,因此它与所有比它小的数都有互质关系.

第5条:因为有(2,4)的存在,因此不能是p-2,只能规定为p-1.

第6条:先规定是奇数,排除了2这个公因子的干扰,接着如果要使两位奇数有相同的公因子,除1之外较小的公因子就是3了,而9,7之类的数因为两者相差的数比3还要小,所以也没有拥有其他公因子的可能.

###欧拉函数.
欧拉函数能够统计出:所有小于n的并与n有互质关系的正整数的数量.
求解过程分五种情况,五种情况文中都给出了详细的说明,理解无障碍.

第三种情况:
>如果n是质数的某一个次方，即 n = p<sup>k</sup> (p为质数，k为大于等于1的整数)

只有当一个数不包含p才可能与n互质,包含p的有无数个( p<sup>k-1</sup> ),最后一个的值为p<sup>k-1</sup>×p,把这些数都去掉,那剩下的就是跟n互质的数了.

第四种情况:积的欧拉函数等于各个因子的欧拉函数之积。<br>
例子:φ(56)=φ(8×7)=φ(8)×φ(7)=φ(2^3)×φ(7)= 4 ×6 = 24。

第五种情况:任意一个大于1的正整数，都可以写成一系列质数的积。<br>
把前面几种情况合并,推导出一条终极公式,即欧拉函数的通用计算公式:

<img src="/public/upload/images/chart.png" alt="chart">

前面的公式看懂了,这条函数也就好理解了.

###欧拉定理
欧拉定理是RSA算法的核心.公式:

>a<sup>φ(n)</sup> ≡1(mod n)

理解这条公式,这句话是关键:
>a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。

如果知道两个数中的其中一个是质数,例如a,b.b为质数,那这条公式可以简写为:

这也是欧拉定理的特例:费马小定理.

###模反元素
>如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。

例子:a = 3,n = 7互质,3的模反元素是5,推导过程:{(3 ×b)-1} % 7 = 0.即 b = 5.
>如果b是a的模反元素，则 b+kn 都是a的模反元素。即 5 + 7K都是3的模反元素

用欧拉定理可以用来证明模反元素的公式如下:

<img src="/public/upload/images/formula.png" alt="fomula">

这里把a看成上面的a,a<sup>φ(n)-1</sup>看成上面的b,得到a的 φ(n)-1 次方,就是a的模反元素。    
基本公式到这里都讲完了,接着再深入文章的第二篇.

###密匙生成的步骤
1.选择两个质数p,q.

2.计算出两者的乘积n, n将成为公匙和私匙中的一部分.

3.求乘积的欧拉函数,直接套用欧拉函数的第四和第二种情况,得到φ(n).

4.随机选择一个整数e,使得 1< e < φ(n),且e与φ(n) 互质, e为公匙的一部分.

5.求出e对于φ(n)的模反元素d,即是求出一个二元一次方程的解,解法可用[擴展歐幾里德演算法](http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95),附上用Python实现的方法

```python
def Ext_Euclid ( a , b ):
    if (b == 0):
        return 1 , 0 , a;
    else:
        x , y , q=Ext_Euclid( b , a % b );
        x , y = y,( x - a / b * y );
        return x , y , q;
```
这里的d为私匙的一部分.

公匙(n,e)和私匙(n,d).两者共同拥有相同的数n,想要破解,就得求出d的值,求d的值必须对n进行因式分解,分解办法唯有对其进行暴力破解.

如果n足够大,要对其进行破解几乎是不可能的.

###加密和解密
想要发送信息m(m必须是整数),就得用(n,e) 对其加密,把加密后的信息设为c,c的值必须小于n,可以用下面公式求出:

>me ≡ c (mod n)

将n取到手之后,用私匙对其进行解密,解密的公式如下:

>cd ≡ m (mod n)

对加密方法的补充:
>公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种"对称性加密算法"（比如[DES](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96)），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。

剩下的就是对加密,解密方法进行证明,这些在文章中都写得很详细,也没什么好记的了.    
这篇文章总共写了3个钟,很久没接触到数学公式了,还是有点吃不消啊.    

参阅:    
[RSA算法原理(一)](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)    
[RSA算法原理(二)](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)    
[擴展歐幾里得演算法](http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)


